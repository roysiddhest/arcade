<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>mini Arcade</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #5dade2, #7d3c98);
            min-height: 100vh;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 99vw;
            max-height: 99vh;
            overflow-y: auto;
        }

        .logo {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 24px;
            color: #fff;
        }

        .game-selector {
            display: block;
        }

        .game-selector.hidden { display: none; }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 14px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 35px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.25);
        }

        .game-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .game-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .game-desc {
            font-size: 12px;
            opacity: 0.8;
        }

        .game-screen {
            display: none;
        }

        .game-screen.active { display: block; }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            position: relative;
        }


        .hs-btn {
            background: rgba(52, 152, 219, 0.3);
        }

 .high-scores {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.9);
    color: #000;  /* black text */
    padding: 20px;
    border-radius: 15px;
    text-align: center;
    display: none;
    z-index: 1000;
    max-width: 92vw;
    max-height: 90vh;
    overflow-y: auto;
}

        .game-name {
            font-size: 24px;
            font-weight: 700;
        }

        .back-btn, .restart-btn {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: rgba(46, 204, 113, 0.8);
            color: white;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .restart-btn {
            background: rgba(52, 152, 219, 0.8);
        }

        .back-btn:hover, .restart-btn:hover {
            background: rgba(46, 204, 113, 1);
            transform: translateY(-1px);
        }

        .restart-btn:hover {
            background: rgba(52, 152, 219, 1);
        }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: #000;
            margin-bottom: 15px;
            max-width: 94vw;
            max-height: 94vw;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            padding: 10px 10px;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .score {
            font-size: 18px;
            font-weight: 700;
        }

        .info {
            font-size: 11px;
            opacity: 0.8;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .mobile-controls {
            display: none;
            margin-top: 15px;
            grid-template-areas: ". up ." "left down right";
            grid-template-columns: 80px 80px 80px;
            grid-template-rows: 80px 80px;
            gap: 15px;
            justify-content: center;
            touch-action: manipulation;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .control-btn:hover, .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .control-btn:nth-child(1) { grid-area: up; }
        .control-btn:nth-child(2) { grid-area: left; }
        .control-btn:nth-child(3) { grid-area: down; }
        .control-btn:nth-child(4) { grid-area: right; }

        .two-btn-controls {
            display: none;
            margin-top: 15px;
            justify-content: center;
            gap: 40px;
            touch-action: manipulation;
        }
        #racer-canvas {
        width: auto;
        height: 84vh;     /* Wide rectangle */
    }

        .wide-btn {
            background: rgba(46, 204, 113, 0.3);
            border: 2px solid rgba(46, 204, 113, 0.6);
            border-radius: 15px;
            color: white;
            font-size: 20px;
            padding: 20px 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .wide-btn:hover, .wide-btn:active {
            background: rgba(46, 204, 113, 0.6);
            transform: scale(0.95);
            border-color: rgba(46, 204, 113, 0.8);
        }

@media (max-width: 768px) {
  
            .mobile-controls { display: grid; }
            .two-btn-controls { display: flex; }
            
            canvas {
        max-width: calc(100vw - 5px);
        max-height: calc(100vh - 10px);
        width: auto;
        height: auto;
        touch-action: none;
    }
    #racer-canvas {
        width: 96vw;
        height: 80vh;     /* Wide rectangle */
    }
    .container {
                padding: 8px;
                max-width: 100vw;
                max-height: 100vh;
            }
    .controls {
        padding: 8px 8px;      /* Smaller padding */
        margin-bottom: 6px;     /* Less margin */
        font-size: 12px;        /* Smaller text */
    }
    
    .game-header {
        margin-bottom: 6px;     /* Less header spacing */
    }
    
    .restart-btn, .back-btn {
        padding: 6px 10px;      /* Smaller buttons */
        font-size: 11px;        /* Smaller button text */
    }
    body {
        padding: 0;             /* Remove body padding */
        margin: 0;              /* Remove body margins */
    }
    #dodge-canvas {
        width: 96vw; 
        height: auto;  /* keep aspect ratio */
    }
    #snake-canvas {
        width: 96vw; 
        height: auto;  /* keep aspect ratio */
    }
    #pong-canvas {
        width: 96vw; 
        height: auto;  /* keep aspect ratio */
    }
    #breakout-canvas {
        width: 96vw; 
        height: auto;  /* keep aspect ratio */
    }
            .high-scores {
            max-width: 90vw;
            width: 75vw;
    }
            .games-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 16px;
                max-width: 100%;
            }
            .game-card {
                padding: 30px;
                margin: 0 2px; 
                
            }
            .logo {
        font-size: 24px;        /* Smaller logo */
        margin-bottom: 14px;    /* Less space below logo */
    }
    #tetris-canvas {
        width: 56vw;
        height: 99vw;   /* Tall rectangle */
    }
    
        }
    
/* Global info & HS buttons */
.info-btn, .hs-btn {
    position: fixed;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.1);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    z-index: 1100;
}

.info-btn { top: 10px; left: 10px; }
.hs-btn { top: 10px; right: 10px; }

/* Info text styling */
.info-text {
    position: fixed;
    top: 50px;
    left: 10px;
    font-size: 12px;
    color: #000; /* black text */
    background: rgba(255, 255, 255, 0.8); /* translucent white */
    padding: 6px 10px;
    border-radius: 8px;  /* smooth rounded corners */
    display: none;
    z-index: 1100;
    white-space: nowrap;
}


</style>
</head>
<body>
<div class="container">
<!-- Game Selector -->
<div class="game-selector" id="selector">
    <h1 class="logo">mini Arcade</h1>
<div class="games-grid">
    <div class="game-card" onclick="startGame('racer')">
<div class="game-icon">🏎️</div>
<div class="game-title">Race Car</div>
<div class="game-desc">Zip Through</div>
</div>
<div class="game-card" onclick="startGame('snake')">
<div class="game-icon">🐍</div>
<div class="game-title">Snake</div>
<div class="game-desc">Eat and Grow</div>
</div>
<div class="game-card" onclick="startGame('dodge')">
<div class="game-icon">⚡</div>
<div class="game-title">Dodge</div>
<div class="game-desc">Avoid Shapes</div>
</div>
<div class="game-card" onclick="startGame('pong')">
<div class="game-icon">🏓</div>
<div class="game-title">Pong</div>
<div class="game-desc">Classic Paddle</div>
</div>
<div class="game-card" onclick="startGame('breakout')">
<div class="game-icon">🧱</div>
<div class="game-title">Breakout</div>
<div class="game-desc">Break Blocks</div>
</div>
<div class="game-card" onclick="startGame('tetris')">
<div class="game-icon">🧩</div>
<div class="game-title">Tetris</div>
<div class="game-desc">Clear Stack</div>
</div>
</div>
</div>
<!-- Game Screens -->
<div class="game-screen" id="snake-game">
<div class="game-header">
<div class="game-name">🐍 Snake</div>
<button class="back-btn" onclick="backToMenu()">← Back</button>
</div>
<canvas height="500" id="snake-canvas" width="500"></canvas>
<div class="controls">
<div class="score">Score: <span id="snake-score">0</span></div>
<button class="restart-btn" onclick="restartGame('snake')">Restart</button>
</div>
</div>
<div class="game-screen" id="tetris-game">
<div class="game-header">
<div class="game-name">🧩 Tetris</div>
<button class="back-btn" onclick="backToMenu()">← Back</button>
</div>
<canvas height="640" id="tetris-canvas" width="320"></canvas>
<div class="controls">
<div class="score">Score: <span id="tetris-score">0</span></div>
<button class="restart-btn" onclick="restartGame('tetris')">Restart</button>
</div>
</div>
<div class="game-screen" id="breakout-game">
<div class="game-header">
<div class="game-name">🧱 Breakout</div>
<button class="back-btn" onclick="backToMenu()">← Back</button>
</div>
<canvas height="450" id="breakout-canvas" width="600"></canvas>
<div class="controls">
<div class="score">Score: <span id="breakout-score">0</span></div>
<button class="restart-btn" onclick="restartGame('breakout')">Restart</button>
</div>
</div>
<div class="game-screen" id="pong-game">
<div class="game-header">
<div class="game-name">🏓 Pong</div>
<div>
<button class="back-btn" id="mode-btn" onclick="togglePongMode()">2P Mode</button>
<button class="back-btn" onclick="backToMenu()">← Back</button>
</div>
</div>
<canvas height="400" id="pong-canvas" width="600"></canvas>
<div class="controls">
  <div class="score">
    <span id="p1-label">You</span>: <span id="p1-score">0</span> | 
    <span id="p2-label">AI</span>: <span id="p2-score">0</span>
  </div>
  <button class="restart-btn" onclick="restartGame('pong')">Restart</button>
</div>

</div>
<div class="game-screen" id="racer-game">
<div class="game-header">
<div class="game-name">🏎️ Race Car</div>
<button class="back-btn" onclick="backToMenu()">← Back</button>
</div>
<canvas height="600" id="racer-canvas" width="400"></canvas>
<div class="controls">
<div class="score">Score: <span id="racer-score">0</span> | Speed: <span id="racer-speed">1</span></div>
<button class="restart-btn" onclick="restartGame('racer')">Restart</button>
</div>
</div>
<div class="game-screen" id="dodge-game">
  <div class="game-header">
    <div class="game-name">⚡ Dodge</div>
    <button class="back-btn" onclick="backToMenu()">← Back</button>
  </div>

  <canvas height="500" id="dodge-canvas" width="500"></canvas>

<div class="controls">
    <div class="score">Score: <span id="dodge-score">0</span></div>
    <button class="restart-btn" onclick="restartGame('dodge')">Restart</button>
</div>
</div>


</div>
<div class="game-over" id="game-over">
<div id="game-over-title">Game Over!</div>
<div id="game-over-score" style="margin: 15px 0;"></div>
<button class="restart-btn" onclick="restartGame(gameType)">Play Again</button>
</div>
<div class="high-scores" id="high-scores">
<h2>🏆 High Scores</h2>
<div id="high-scores-content"></div>
<button class="restart-btn" onclick="hideHighScores()" style="margin-top: 20px;">Close</button>
</div>
<button class="info-btn" onclick="toggleInfo()">i</button>
<div class="info-text" id="infoText">App Developed by Siddhest Roy</div>
<button class="hs-btn" onclick="showHighScores()">HS</button>
</div>
</div>



<script>
        let game = null;
let keys = {};
let touchMoving = false;
let animationFrameId = null;

// High Score System - Using in-memory storage
let highScores = {
    snake: 0, tetris: 0, breakout: 0, 
    pong: 0, racer: 0, dodge: 0
};

document.addEventListener('keydown', e => {
    // Prevent double-move when key is held
    if (e.repeat) return;

    // Check if game over screen is visible and spacebar is pressed
    const gameOverScreen = document.getElementById('game-over');
    if (gameOverScreen && gameOverScreen.style.display === 'block' && e.code === 'Space') {
        e.preventDefault();
        restartGame(gameType);
        return;
    }

    // Snake controls
    if (gameType === 'snake' && game && game.running) {
        if (['ArrowUp','w','W'].includes(e.key)) snakeDir('up');
        if (['ArrowDown','s','S'].includes(e.key)) snakeDir('down');
        if (['ArrowLeft','a','A'].includes(e.key)) snakeDir('left');
        if (['ArrowRight','d','D'].includes(e.key)) snakeDir('right');
    }

    // Tetris controls
    if (gameType === 'tetris' && game && game.running) {
        if (['ArrowLeft','a','A'].includes(e.key)) tetrisMove('left');
        if (['ArrowRight','d','D'].includes(e.key)) tetrisMove('right');
        if (['ArrowDown','s','S'].includes(e.key)) tetrisDrop();
        if (['ArrowUp','w','W'].includes(e.key)) tetrisRotate();
        if (e.code === 'Space') tetrisDrop(); // optional hard drop
    }

    // Breakout controls
    if (gameType === 'breakout' && game && !game.launched) {
        if ([' ','Spacebar','ArrowUp'].includes(e.key)) {
            game.launched = true;
        }
    }

    // Pong controls
    if (gameType === 'pong' && game && !game.started) {
        if (['ArrowUp','ArrowDown','w','W','s','S',' '].includes(e.key)) {
            game.started = true;
        }
    }

    // Track key state globally
    keys[e.key] = true;
});

document.addEventListener('keyup', e => {
    keys[e.key] = false;
});


function saveHighScore(gameType, score) {
    // If score is a number → normal high score check
    if (typeof score === "number") {
        if (score > (highScores[gameType] || 0)) {
            highScores[gameType] = score;
            return true;
        }
        return false;
    }

    // If score is a string (like "5-2") → Pong format
    if (typeof score === "string") {
        const [p1, p2] = score.split('-').map(Number);
        const [bestP1, bestP2] = highScores[gameType]
            ? highScores[gameType].split('-').map(Number)
            : [0, Infinity];

        // Higher P1 wins, then lower P2 is better
        if (p1 > bestP1 || (p1 === bestP1 && p2 < bestP2)) {
            highScores[gameType] = score;
            return true;
        }
        return false;
    }

    return false; // fallback
}



function showHighScores() {
    const hsWindow = document.getElementById('high-scores');

    // if already visible → close it
    if (hsWindow.style.display === 'block') {
        hsWindow.style.display = 'none';
        return;
    }

    // otherwise build content + open
    const content = `
        <div style="font-size: 12px; opacity: 0.7; margin: 5px 0 15px 0;">(resets after refresh)</div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
            <div>🏎️ Race Car: ${highScores.racer}</div>
            <div>🐍 Snake: ${highScores.snake}</div>
            <div>⚡ Dodge: ${highScores.dodge}</div>
            <div>🏓 Pong: ${highScores.pong}</div>
            <div>🧱 Breakout: ${highScores.breakout}</div>
            <div>🧩 Tetris: ${highScores.tetris}</div> 
        </div>
    `;
    document.getElementById('high-scores-content').innerHTML = content;
    hsWindow.style.display = 'block';
}

function hideHighScores() {
    document.getElementById('high-scores').style.display = 'none';
}

let gameType = null;
let dodgeControlsSetup = false;

// Show or hide the Dodge touch buttons
function showDodgeControls(show) {
    const panel = document.getElementById('dodge-touch-controls');
    if (panel) {
        panel.style.display = show ? 'flex' : 'none';
    }
}

// Setup touch controls for Dodge game - unified approach
function setupDodgeTouchControls() {
    if (dodgeControlsSetup) return; // Prevent duplicate setup
    
    const buttons = document.querySelectorAll('.tc-btn');
    
    buttons.forEach(btn => {
        const key = btn.dataset.key; // Should be 'ArrowUp', 'ArrowDown', etc.
        
        // Press handlers
        const handlePress = (e) => {
            e.preventDefault();
            e.stopPropagation();
            keys[key] = true;
        };
        
        // Release handlers
        const handleRelease = (e) => {
            e.preventDefault();
            e.stopPropagation();
            keys[key] = false;
        };
        
        // Touch events
        btn.addEventListener('touchstart', handlePress, { passive: false });
        btn.addEventListener('touchend', handleRelease, { passive: false });
        btn.addEventListener('touchcancel', handleRelease, { passive: false });
        
        // Mouse events (for desktop testing)
        btn.addEventListener('mousedown', handlePress);
        btn.addEventListener('mouseup', handleRelease);
        btn.addEventListener('mouseleave', handleRelease);
        
        // Prevent context menu on long press
        btn.addEventListener('contextmenu', (e) => e.preventDefault());
    });
    
    dodgeControlsSetup = true;
}

function startGame(type) {
    gameType = type; // ✅ moved here so loops see it immediately

    // Hide menu, show game screen
    document.getElementById('selector').classList.add('hidden');
    document.querySelectorAll('.game-screen').forEach(screen => screen.classList.remove('active'));
    document.getElementById(type + '-game').classList.add('active');

    // Initialize the specific game
    switch(type) {
        case 'snake': initSnake(); break;
        case 'tetris': initTetris(); break;
        case 'breakout': initBreakout(); break;
        case 'pong': initPong(); break;
        case 'racer': initRacer(); break;
        case 'dodge': 
            initDodge(); 
            showDodgeControls(true);
            setupDodgeTouchControls();
            break;
    }
}


function stopGameLoop() {
    if(animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    // Stop all potential running games
    if (game) {
        game.running = false;
    }
}

function resetKeys() {
    keys = {
        'ArrowUp': false,
        'ArrowDown': false,
        'ArrowLeft': false,
        'ArrowRight': false
    };
}

function backToMenu() {
    // Critical: Stop everything first
    stopGameLoop();
    if (game) game.running = false;
    game = null;
    gameType = null;

    // Reset scores
    document.getElementById('snake-score').textContent = '0';
    document.getElementById('tetris-score').textContent = '0';
    document.getElementById('breakout-score').textContent = '0';
    document.getElementById('p1-score').textContent = '0';
    document.getElementById('p2-score').textContent = '0';
    document.getElementById('racer-score').textContent = '0';
    document.getElementById('racer-speed').textContent = '60';
    document.getElementById('dodge-score').textContent = '0';

    // Hide all game screens, show menu
    document.querySelectorAll('.game-screen').forEach(screen => screen.classList.remove('active'));
    document.getElementById('selector').classList.remove('hidden');

    // Critical: Properly reset input state
    keys = {};
    if (gameType === 'dodge') {
        showDodgeControls(false);
    }

    hideGameOver();
}
function restartGame(type) {
    // Critical: Complete cleanup before restart
    stopGameLoop();
    if (game) game.running = false;
    game = null;

    // Reset all key states
    keys = {};

    // Reset scores per game
    if (type === 'snake') document.getElementById('snake-score').textContent = '0';
    if (type === 'tetris') document.getElementById('tetris-score').textContent = '0';
    if (type === 'breakout') {
        document.getElementById('breakout-score').textContent = '0';
        hideGameOver();

        // Clear canvas with null check
        const canvas = document.getElementById('breakout-canvas');
        const ctx = canvas.getContext('2d');
        if (ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        setTimeout(() => initBreakout(), 100);
        return;
    }
    if (type === 'pong') {
        document.getElementById('p1-score').textContent = '0';
        document.getElementById('p2-score').textContent = '0';
    }
    if (type === 'racer') {
        document.getElementById('racer-score').textContent = '0';
        document.getElementById('racer-speed').textContent = '60';
    }
    if (type === 'dodge') {
        document.getElementById('dodge-score').textContent = '0';
        showDodgeControls(true);
        setupDodgeTouchControls();
    }

    hideGameOver();
    // Critical: Ensure clean restart
    setTimeout(() => startGame(type), 100);
}

function showGameOver(title, score) {
    document.getElementById('game-over-title').textContent = title;
    document.getElementById('game-over-score').textContent = score;
    document.getElementById('game-over').style.display = 'block';
}

function hideGameOver() {
    document.getElementById('game-over').style.display = 'none';
}

    function initSnake() {
    const canvas = document.getElementById('snake-canvas');
    canvas.width = 20 * 20;
    canvas.height = 20 * 20;

            game = {
                type: 'snake',
                running: true,
                snake: [{x: 10, y: 10}],
                dx: 0, dy: 0,
                food: {x: 15, y: 15},
                score: 0,
                size: 20,
                lastTime: 0,
                frameRate: 110  // Smoother movement
            };
            
            generateFood();
            animationFrameId = requestAnimationFrame(snakeLoop);
        }

        function generateFood() {
    let newFood;
    do {
        newFood = {
            x: Math.floor(Math.random() * 20),
            y: Math.floor(Math.random() * 20)
        };
    } while (game.snake.some(s => s.x === newFood.x && s.y === newFood.y));
    game.food = newFood;
}


        function snakeLoop(currentTime) {
            if (!game || !game.running) return;
            const snakeCanvas = document.getElementById('snake-canvas');
            const canvas = document.getElementById('snake-canvas');
            const ctx = canvas.getContext('2d');
            
            // Control frame rate for smoother movement
            if (currentTime - game.lastTime > game.frameRate) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (game.dx !== 0 || game.dy !== 0) {
                    const head = {
                        x: game.snake[0].x + game.dx,
                        y: game.snake[0].y + game.dy
                    };

                    if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20 ||
                        game.snake.some(s => s.x === head.x && s.y === head.y)) {
                        const isNewRecord = saveHighScore('snake', game.score);
                        const title = isNewRecord ? '🎉 New High Score!' : 'Game Over!';
                        showGameOver(title, `Score: ${game.score}`);
                        return;
                    }

                    game.snake.unshift(head);

                    if (head.x === game.food.x && head.y === game.food.y) {
                        game.score += 10;
                        document.getElementById('snake-score').textContent = game.score;
                        generateFood();
                    } else {
                        game.snake.pop();
                    }
                }

                // Blue snake body
                ctx.fillStyle = '#0074D9';
                game.snake.forEach(s => {
                    ctx.fillRect(s.x * 20, s.y * 20, 19, 19);
                });

                // Green food dot
                ctx.fillStyle = '#2ECC40';
                ctx.beginPath();
                ctx.arc(game.food.x * 20 + 10, game.food.y * 20 + 10, 10, 0, 2 * Math.PI);
                ctx.fill();

                game.lastTime = currentTime;
            }
            
            animationFrameId = requestAnimationFrame(snakeLoop);
        }

        function snakeDir(dir) {
    if (!game || !game.running) return;
    if (dir === 'up' && game.dy === 0) { game.dx = 0; game.dy = -1; }
    else if (dir === 'down' && game.dy === 0) { game.dx = 0; game.dy = 1; }
    else if (dir === 'left' && game.dx === 0) { game.dx = -1; game.dy = 0; }
    else if (dir === 'right' && game.dx === 0) { game.dx = 1; game.dy = 0; }
}


        // Snake touch controls
        let snakeTouchStartX = null, snakeTouchStartY = null;
        const snakeCanvas = document.getElementById('snake-canvas');
        
        snakeCanvas.addEventListener('touchstart', e => {
            e.preventDefault();
            snakeTouchStartX = e.changedTouches[0].clientX;
            snakeTouchStartY = e.changedTouches[0].clientY;
        });
        
        snakeCanvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (snakeTouchStartX === null || snakeTouchStartY === null) return;

            let dx = e.changedTouches[0].clientX - snakeTouchStartX;
            let dy = e.changedTouches[0].clientY - snakeTouchStartY;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
                if (dx > 0) snakeDir('right');
                else snakeDir('left');
            } else if (Math.abs(dy) > 30) {
                if (dy > 0) snakeDir('down');
                else snakeDir('up');
            }

            snakeTouchStartX = snakeTouchStartY = null;
        });

       // Tetris Game - Fixed with proper error handling
        const COLS = 10;
        const ROWS = 20;
        const CELL = 32;
        const WIDTH = COLS * CELL;
        const HEIGHT = ROWS * CELL;

        function initTetris() {
    const canvas = document.getElementById('tetris-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return; // Critical: Prevent errors if context fails
    
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    game = {
        type: 'tetris',
        running: true,
        grid: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
        drop: 0,
        interval: 500,
        last: 0,
        score: 0
    };
    newPiece();
    animationFrameId = requestAnimationFrame(tetrisLoop);
}

        const TETROMINOS = {
            I: [[1, 1, 1, 1]],
            O: [[1, 1], [1, 1]],
            T: [[0, 1, 0], [1, 1, 1]],
            S: [[0, 1, 1], [1, 1, 0]],
            Z: [[1, 1, 0], [0, 1, 1]],
            J: [[1, 0, 0], [1, 1, 1]],
            L: [[0, 0, 1], [1, 1, 1]]
        };
        
        const COLORS = {
            I: '#00f0f0', O: '#f0f000', T: '#a000f0',
            S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#f0a000'
        };

        function newPiece() {
            if (!game) return;
            const types = Object.keys(TETROMINOS);
            const type = types[Math.floor(Math.random() * types.length)];
            game.piece = TETROMINOS[type].map(r => [...r]);
            game.color = COLORS[type];
            game.x = Math.floor(COLS / 2) - Math.ceil(game.piece[0].length / 2);
            game.y = 0;
        }

        function tetrisLoop(time) {
            if (!game || !game.running || gameType !== 'tetris') return;

            const canvas = document.getElementById('tetris-canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            if (!game.last) game.last = time;
            game.drop += time - game.last;
            game.last = time;

            if (game.drop > game.interval) {
                if (!collision(0, 1)) {
                    game.y++;
                } else {
                    placePiece();
                }
                game.drop = 0;
            }

            drawTetris();
            animationFrameId = requestAnimationFrame(tetrisLoop);
        }

       function drawTetris() {
    if (!game) return;
    const canvas = document.getElementById('tetris-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return; // Critical: Prevent null context errors
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw grid
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (game.grid[y][x]) {
                ctx.fillStyle = game.grid[y][x];
                ctx.fillRect(x * CELL, y * CELL, CELL - 1, CELL - 1);
            }
        }
    }

    // Draw current piece
    if (game.piece && game.color) {
        ctx.fillStyle = game.color;
        for (let y = 0; y < game.piece.length; y++) {
            for (let x = 0; x < game.piece[y].length; x++) {
                if (game.piece[y][x]) {
                    ctx.fillRect((game.x + x) * CELL, (game.y + y) * CELL, CELL - 1, CELL - 1);
                }
            }
        }
    }
}

        function tetrisRotate() {
            if (!game || !game.running || !game.piece) return;
            const rotated = game.piece[0].map((_, i) =>
                game.piece.map(row => row[i]).reverse()
            );
            const orig = game.piece;
            game.piece = rotated;
            if (collision()) game.piece = orig;
        }

        function tetrisMove(dir) {
            if (!game || !game.running) return;
            if (dir === 'left') {
                game.x -= 1;
                if (collision()) game.x += 1;
            }
            else if (dir === 'right') {
                game.x += 1;
                if (collision()) game.x -= 1;
            }
        }

        function tetrisDrop() {
            if (!game || !game.running) return;
            while (!collision(0, 1)) game.y++;
            placePiece();
        }

        function placePiece() {
            if (!game || !game.piece) return;
            
            for (let y = 0; y < game.piece.length; y++) {
                for (let x = 0; x < game.piece[y].length; x++) {
                    if (game.piece[y][x]) {
                        const gx = game.x + x, gy = game.y + y;
                        if (gy < 0) { 
                            const isNewRecord = saveHighScore('tetris', game.score);
                            const title = isNewRecord ? '🎉 New High Score!' : 'Game Over!';
                            showGameOver(title, `Score: ${game.score}`);
                            game.running = false;
                            return;
                        }
                        game.grid[gy][gx] = game.color;
                    }
                }
            }

            // Clear full lines
            for (let y = ROWS - 1; y >= 0; y--) {
                if (game.grid[y].every(c => c)) {
                    game.grid.splice(y, 1);
                    game.grid.unshift(Array(COLS).fill(null));
                    y++;
                    game.score += 100;
                    document.getElementById('tetris-score').textContent = game.score;
                }
            }

            newPiece();
            if (collision()) {
                const isNewRecord = saveHighScore('tetris', game.score);
                const title = isNewRecord ? '🎉 New High Score!' : 'Game Over!';
                showGameOver(title, `Score: ${game.score}`);
                game.running = false;
            }
        }

        function collision(offX = 0, offY = 0, piece = game?.piece) {
    if (!game || !piece || !game.grid) return true; // Critical: Check grid exists
    
    for (let y = 0; y < piece.length; y++) {
        for (let x = 0; x < piece[y].length; x++) {
            if (!piece[y][x]) continue;
            const nx = game.x + x + offX;
            const ny = game.y + y + offY;
            
            // Critical: More thorough boundary checks
            if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
            if (ny >= 0 && game.grid[ny] && game.grid[ny][nx]) return true;
        }
    }
    return false;
}

        // Tetris touch controls
        let tetrisStartX = null, tetrisStartY = null;
        const tetrisCanvas = document.getElementById('tetris-canvas');

        tetrisCanvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            tetrisStartX = t.clientX; 
            tetrisStartY = t.clientY;
        });

        tetrisCanvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (tetrisStartX === null || tetrisStartY === null) return;
            const t = e.changedTouches[0];
            const dx = t.clientX - tetrisStartX;
            const dy = t.clientY - tetrisStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 30) tetrisMove('right');
                else if (dx < -30) tetrisMove('left');
            } else {
                if (dy > 30) tetrisDrop();
                else if (dy < -30) tetrisRotate();
                else tetrisRotate();
            }
            tetrisStartX = tetrisStartY = null;
        });


        // Breakout Game - Hard Mode
function initBreakout() {
    const canvas = document.getElementById('breakout-canvas');
    if (!canvas) return;
    
    game = {
        type: 'breakout',
        running: true,
        paddle: { 
            x: canvas.width/2 - 60, 
            y: canvas.height - 30, 
            w: 120, h: 15,
            targetX: canvas.width/2 - 60  // Keep for touch controls
        },
        ball: { 
            x: canvas.width/2, 
            y: canvas.height - 50, 
            dx: 8, dy: -8, 
            r: 10 
        },
        blocks: [], 
        score: 0, 
        lives: 1, 
        launched: false
    };
    
    const colors = ['#e74c3c', '#8e44ad', '#f1c40f', '#27ae60', '#3498db'];
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 15; col++) {
            game.blocks.push({
                x: col * 40, 
                y: row * 20 + 50, 
                w: 35, h: 15,
                color: colors[row % 5], 
                alive: true
            });
        }
    }
    
    canvas.addEventListener('click', () => {
        if (game && !game.launched) game.launched = true;
    });

    animationFrameId = requestAnimationFrame(breakoutLoop);
}
    

// Fix Breakout - restore easing for touch, keep direct keyboard movement
function breakoutLoop() {
    if (!game || !game.running || gameType !== 'breakout') return;
    
    const canvas = document.getElementById('breakout-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Direct keyboard movement only
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        game.paddle.x -= 8;
    }
    if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        game.paddle.x += 8;
    }
    
    game.paddle.x = Math.max(0, Math.min(canvas.width - game.paddle.w, game.paddle.x));
    
    if (game.launched) {
        game.ball.x += game.ball.dx;
        game.ball.y += game.ball.dy;
        
        if (game.ball.x <= game.ball.r || game.ball.x >= canvas.width - game.ball.r) game.ball.dx = -game.ball.dx;
        if (game.ball.y <= game.ball.r) game.ball.dy = -game.ball.dy;
        
        if (game.ball.y >= canvas.height) {
            game.lives--;
            if (game.lives <= 0) {
                const isNewRecord = saveHighScore('breakout', game.score);
                const title = isNewRecord ? '🎉 New High Score!' : 'Game Over!';
                showGameOver(title, `Score: ${game.score}`);
                return;
            }
            game.ball.x = canvas.width/2;
            game.ball.y = canvas.height - 50;
            game.ball.dx = 8;
            game.ball.dy = -8;
            game.launched = false;
        }
        
        if (game.ball.y + game.ball.r >= game.paddle.y &&
            game.ball.x >= game.paddle.x && game.ball.x <= game.paddle.x + game.paddle.w) {
            game.ball.dy = -Math.abs(game.ball.dy);
            const hit = (game.ball.x - game.paddle.x) / game.paddle.w;
            game.ball.dx = (hit - 0.5) * 12;
            game.ball.dx *= 1.01;
            game.ball.dy *= 1.01;
        }
        
        let blockHit = false;
        for (let block of game.blocks) {
            if (!blockHit && block.alive && 
                game.ball.x + game.ball.r >= block.x && 
                game.ball.x - game.ball.r <= block.x + block.w &&
                game.ball.y + game.ball.r >= block.y && 
                game.ball.y - game.ball.r <= block.y + block.h) {
                
                block.alive = false;
                game.ball.dy = -game.ball.dy;
                game.score += 10;
                document.getElementById('breakout-score').textContent = game.score;
                blockHit = true;

                if (game.blocks.every(b => !b.alive)) {
                    const isNewRecord = saveHighScore('breakout', game.score);
                    const title = isNewRecord ? '🎉 New High Score!' : 'You Win!';
                    showGameOver(title, `Score: ${game.score}`);
                    return;
                }
            }
        }
    } else {
        game.ball.x = game.paddle.x + game.paddle.w / 2;
        game.ball.y = game.paddle.y - game.ball.r;
    }
    
    game.blocks.forEach(b => {
        if (b.alive) {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, b.y, b.w, b.h);
        }
    });
    
    ctx.fillStyle = '#e32222';
    ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.w, game.paddle.h);
    
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.r, 0, Math.PI * 2);
    ctx.fill();
    
    animationFrameId = requestAnimationFrame(breakoutLoop);
}


document.getElementById('breakout-canvas').addEventListener('touchmove', e => {
    e.preventDefault();
    if (!game) return;
    let rect = e.target.getBoundingClientRect();
    let x = e.touches[0].clientX - rect.left;
    let canvasX = x * (e.target.width / rect.width);
    
    game.paddle.x = canvasX - game.paddle.w / 2;
    game.paddle.x = Math.max(0, Math.min(e.target.width - game.paddle.w, game.paddle.x));
});

document.addEventListener('keydown', e => {
    if (gameType === 'breakout' && game && !game.launched) {
        if (['ArrowUp',' ','Spacebar'].includes(e.key)) {
            game.launched = true;
        }
    }
});

document.getElementById('breakout-canvas').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (game && !game.launched) game.launched = true;
});


        // Pong Game - Fixed
       let pongMode = false; // false = 1P mode by default
        
function togglePongMode() {
    pongMode = !pongMode;

    const btn = document.getElementById('mode-btn');
    const p1Label = document.getElementById('p1-label');
    const p2Label = document.getElementById('p2-label');

    if (pongMode) {
        // switched into 2P mode
        if (btn) btn.textContent = '1P Mode'; 
        if (p1Label) p1Label.textContent = 'P1';
        if (p2Label) p2Label.textContent = 'P2';
    } else {
        // switched into 1P mode
        if (btn) btn.textContent = '2P Mode'; 
        if (p1Label) p1Label.textContent = 'You';
        if (p2Label) p2Label.textContent = 'AI';
    }

    restartGame('pong');
}


    function initPong() {
    const canvas = document.getElementById('pong-canvas');
    if (!canvas) return;
    
    game = {
        type: 'pong',
        running: true,
        p1: { 
            x: 20, 
            y: canvas.height/2 - 50, 
            w: 15, h: 100,
            targetY: canvas.height/2 - 50  // Keep for touch controls
        },
        p2: { 
            x: canvas.width - 35, 
            y: canvas.height/2 - 50, 
            w: 15, h: 100,
            targetY: canvas.height/2 - 50  // Keep for touch controls
        },
        ball: { x: canvas.width/2, y: canvas.height/2, dx: 9, dy: 6, r: 10 },
        score1: 0, score2: 0, started: false
    };
    
    animationFrameId = requestAnimationFrame(pongLoop);
}

   function pongLoop() {
    if (!game || !game.running || gameType !== 'pong') return;
    
    const canvas = document.getElementById('pong-canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);
    
    if (game.started) {
        game.ball.x += game.ball.dx;
        game.ball.y += game.ball.dy;
        
        if (game.ball.y - game.ball.r <= 0) {
            game.ball.y = game.ball.r;
            game.ball.dy = Math.abs(game.ball.dy);
        }
        if (game.ball.y + game.ball.r >= canvas.height) {
            game.ball.y = canvas.height - game.ball.r;
            game.ball.dy = -Math.abs(game.ball.dy);
        }
        
        if (game.ball.x - game.ball.r <= game.p1.x + game.p1.w && 
            game.ball.y >= game.p1.y && game.ball.y <= game.p1.y + game.p1.h) {
            game.ball.dx = Math.abs(game.ball.dx);
            game.ball.dy = (game.ball.y - game.p1.y - 50) * 0.08;
        }
        
        if (game.ball.x + game.ball.r >= game.p2.x && 
            game.ball.y >= game.p2.y && game.ball.y <= game.p2.y + game.p2.h) {
            game.ball.dx = -Math.abs(game.ball.dx);
            game.ball.dy = (game.ball.y - game.p2.y - 50) * 0.08;
        }
        
        if (game.ball.x < 0) {
            game.score2++;
            document.getElementById('p2-score').textContent = game.score2;
            resetBall();
            if (game.score2 >= 5) { 
                const title = pongMode ? 'Player 2 Wins!' : 'AI Wins!';
                showGameOver(title, `Final: ${game.score1}-${game.score2}`); 
                return; 
            }
        }
        
        if (game.ball.x > canvas.width) {
            game.score1++;
            document.getElementById('p1-score').textContent = game.score1;
            resetBall();
            if (game.score1 >= 5) { 
                const scoreStr = `${game.score1}-${game.score2}`;
                const isNewRecord = saveHighScore('pong', scoreStr);
                const title = isNewRecord ? '🎉 New High Score!' : 'Player 1 Wins!';
                showGameOver(title, `Final: ${scoreStr}`); 
                return; 
            }
        }
        
        if (!pongMode) {
            const aiTarget = game.ball.y - 50;
            game.p2.y += (aiTarget - game.p2.y) * 0.08;
            game.p2.y = Math.max(0, Math.min(canvas.height - game.p2.h, game.p2.y));
        }
    }
    
    // Direct P1 movement
    if (keys['w'] || keys['W'] || (!pongMode && keys['ArrowUp'])) {
        game.p1.y -= 8;
    }
    if (keys['s'] || keys['S'] || (!pongMode && keys['ArrowDown'])) {
        game.p1.y += 8;
    }
    game.p1.y = Math.max(0, Math.min(canvas.height - game.p1.h, game.p1.y));
    
    if (pongMode) {
        // Direct P2 movement in 2P mode
        if (keys['ArrowUp']) {
            game.p2.y -= 8;
        }
        if (keys['ArrowDown']) {
            game.p2.y += 8;
        }
        game.p2.y = Math.max(0, Math.min(canvas.height - game.p2.h, game.p2.y));
    }
    
    ctx.fillStyle = '#4ecdc4';
    ctx.fillRect(game.p1.x, game.p1.y, game.p1.w, game.p1.h);
    
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(game.p2.x, game.p2.y, game.p2.w, game.p2.h);
    
    ctx.fillStyle = '#ffd93d';
    ctx.beginPath();
    ctx.arc(game.ball.x, game.ball.y, game.ball.r, 0, Math.PI * 2);
    ctx.fill();
    
    animationFrameId = requestAnimationFrame(pongLoop);
}

        function resetBall() {
            if (!game) return;
            const canvas = document.getElementById('pong-canvas');
            game.ball.x = canvas.width/2;
            game.ball.y = canvas.height/2;
            game.ball.dx = Math.random() > 0.5 ? 9 : -9;
            game.ball.dy = (Math.random() - 0.5) * 12;
            game.started = false;
            setTimeout(() => { if (game) game.started = true; }, 1000);
        }

    document.getElementById('pong-canvas').addEventListener('touchmove', e => {
    e.preventDefault();
    if (!game) return;
    let rect = e.target.getBoundingClientRect();

    for (let i = 0; i < e.touches.length; i++) {
        let touch = e.touches[i];
        let x = touch.clientX - rect.left;
        let y = touch.clientY - rect.top;
        let canvasY = y * (e.target.height / rect.height);

        if (x < rect.width / 2) {
            // Left half → P1
            game.p1.y = canvasY - game.p1.h / 2;
            game.p1.y = Math.max(0, Math.min(e.target.height - game.p1.h, game.p1.y));
        } else if (pongMode) {
            // Right half → P2 (only in 2P mode)
            game.p2.y = canvasY - game.p2.h / 2;
            game.p2.y = Math.max(0, Math.min(e.target.height - game.p2.h, game.p2.y));
        }
    }
});

        document.addEventListener('keydown', e => {
    if (gameType === 'pong' && game && !game.started) {
        if (['ArrowUp','ArrowDown','w','W','s','S',' '].includes(e.key)) {
            game.started = true;
        }
    }
});


        document.getElementById('pong-canvas').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game && !game.started) game.started = true;
        });

        // Car Racing Game - Fixed
        function initRacer() {
            const canvas = document.getElementById('racer-canvas');
            if (!canvas) return;
            
            game = {
                type: 'racer',
                running: true,
                car: { x: 185, y: canvas.height - 100, w: 30, h: 50, lane: 1 },
                enemies: [], score: 0, speed: 4, enemyTimer: 0, roadOffset: 0
            };
            
            const speedElement = document.getElementById('racer-speed');
            if (speedElement) speedElement.textContent = '60';
            animationFrameId = requestAnimationFrame(racerLoop);
        }

        function drawCar(ctx, x, y, w, h, color, isPlayer = false) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + 5, y);
            ctx.lineTo(x + w - 5, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + 5);
            ctx.lineTo(x + w, y + h - 5);
            ctx.quadraticCurveTo(x + w, y + h, x + w - 5, y + h);
            ctx.lineTo(x + 5, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - 5);
            ctx.lineTo(x, y + 5);
            ctx.quadraticCurveTo(x, y, x + 5, y);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = "#2c3e50";

            if (isPlayer) {
                ctx.fillRect(x + 4, y + 3, w - 8, h * 0.25);
                ctx.fillRect(x + 4, y + h * 0.7, w - 8, h * 0.25);
                ctx.fillStyle = "#ffeb3b";
                ctx.fillRect(x + 2, y + 2, 4, 6);
                ctx.fillRect(x + w - 6, y + 2, 4, 6);
                ctx.fillStyle = "#f00";
                ctx.fillRect(x + 2, y + h - 8, 4, 6);
                ctx.fillRect(x + w - 6, y + h - 8, 4, 6);
                ctx.fillStyle = "rgba(30, 30, 30, 0.8)";
                ctx.fillRect(x + w * 0.25, y + h * 0.4, w * 0.5, h * 0.2);
            } else {
                ctx.fillRect(x + 4, y + h * 0.7, w - 8, h * 0.25);
                ctx.fillRect(x + 4, y + 3, w - 8, h * 0.25);
                ctx.fillStyle = "#ffeb3b";
                ctx.fillRect(x + 2, y + h - 8, 4, 6);
                ctx.fillRect(x + w - 6, y + h - 8, 4, 6);
                ctx.fillStyle = "#f00";
                ctx.fillRect(x + 2, y + 2, 4, 6);
                ctx.fillRect(x + w - 6, y + 2, 4, 6);
            }
        }

        function drawTruck(ctx, x, y, w, h) {
            ctx.fillStyle = '#e7a53c';
            ctx.fillRect(x, y, w, h * 0.8);
            ctx.fillStyle = '#c0a72b';
            ctx.fillRect(x, y + h * 0.7, w, h * 0.3);
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(x + 3, y + h * 0.75, w - 6, h * 0.15);
            ctx.fillStyle = '#999';
            ctx.fillRect(x + 2, y + h - 6, w - 4, 4);
            ctx.fillStyle = '#ffeb3b';
            ctx.fillRect(x + 2, y + h - 10, 4, 4);
            ctx.fillRect(x + w - 6, y + h - 10, 4, 4);
        }

        function racerLoop() {
            if (!game || !game.running || gameType !== 'racer') return;
            
            const canvas = document.getElementById('racer-canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            game.roadOffset += 3 + game.speed;
            if (game.roadOffset > 40) game.roadOffset = 0;
            
            ctx.fillStyle = '#f39c12';
            for (let i = -40; i < canvas.height + 40; i += 40) {
                ctx.fillRect(canvas.width/3 - 2, i + game.roadOffset, 4, 20);
                ctx.fillRect(2*canvas.width/3 - 2, i + game.roadOffset, 4, 20);
            }

            if ((keys['ArrowLeft'] || keys['a'] || keys['A']) && game.car.lane > 0) {
                game.car.lane -= 1;
                keys['ArrowLeft'] = keys['a'] = keys['A'] = false;
            }
            if ((keys['ArrowRight'] || keys['d'] || keys['D']) && game.car.lane < 2) {
                game.car.lane += 1;
                keys['ArrowRight'] = keys['d'] = keys['D'] = false;
            }
            
            const laneX = [canvas.width/6 - 15, canvas.width/2 - 15, 5*canvas.width/6 - 15];
            game.car.x += (laneX[game.car.lane] - game.car.x) * 0.15;
            
            game.enemyTimer++;
            if (game.enemyTimer > Math.max(30, 90 - game.speed * 8)) {
                const lanesToSpawn = Math.random() < 0.5 ? 1 : 2;
                const laneIndices = [0, 1, 2].sort(() => Math.random() - 0.5);

                for (let i = 0; i < lanesToSpawn; i++) {
                    const lane = laneIndices[i];
                    const vehicleType = Math.random() > 0.6 ? 'truck' : 'car';
                    game.enemies.push({
                        x: laneX[lane],
                        y: -60,
                        w: 30,
                        h: vehicleType === 'truck' ? 60 : 50,
                        type: vehicleType,
                        lane: lane
                    });
                }
                game.enemyTimer = 0;
            }
            
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                enemy.y += 3 + game.speed;
                
                if (enemy.y > canvas.height) {
                    game.enemies.splice(i, 1);
                    game.score += 10;
                    if (game.score % 100 === 0) {
                        game.speed += 1; 
                        const speedElement = document.getElementById('racer-speed');
                        if (speedElement) speedElement.textContent = (game.speed*10)+20;
                    }
                    const scoreElement = document.getElementById('racer-score');
                    if (scoreElement) scoreElement.textContent = game.score;
                    continue;
                }
                
                if (Math.abs(game.car.x - enemy.x) < 25 && Math.abs(game.car.y - enemy.y) < 40) {
                    const isNewRecord = saveHighScore('racer', game.score);
                    const title = isNewRecord ? '🎉 New High Score!' : 'Crashed!';
                    showGameOver(title, `Score: ${game.score}`);
                    return;
                }
                
                if (enemy.type === 'truck') {
                    drawTruck(ctx, enemy.x, enemy.y, enemy.w, enemy.h);
                } else {
                    drawCar(ctx, enemy.x, enemy.y, enemy.w, enemy.h, '#e74c3c', false);
                }
            }
            
            drawCar(ctx, game.car.x, game.car.y, game.car.w, game.car.h, '#3498db', true);
            animationFrameId = requestAnimationFrame(racerLoop);
        }

        function racerMove(dir) {
            if (!game || !game.running) return;
            if (dir === 'left' && game.car.lane > 0) game.car.lane -= 1;
            else if (dir === 'right' && game.car.lane < 2) game.car.lane += 1;
        }

        document.getElementById('racer-canvas').addEventListener('touchstart', e => {
            e.preventDefault();
            if (!game || !game.running) return;
            
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            
            if (touchX < rect.width / 2) {
                racerMove('left');
            } else {
                racerMove('right');
            }
        });

        // Dodge Game - Modified for smooth movement with velocity and friction
function initDodge() {
    const canvas = document.getElementById('dodge-canvas');

    game = {
        type: 'dodge',
        running: true,
        score: 0,
        timer: 0,
        baseObstacleSpeed: 5,
        obstacles: [],
        player: {
            x: canvas.width / 2,
            y: canvas.height / 2,
            r: 15,
            vx: 0,
            vy: 0
        }
    };

    document.getElementById('dodge-score').textContent = '0';
    animationFrameId = requestAnimationFrame(dodgeLoop);
}

// Updated obstacle colors
const OBSTACLE_COLORS = [
    '#FF4444', // Red
    '#FF8800', // Orange  
    '#FFDD00', // Yellow
    '#44FF44', // Green
    '#0088FF', // Blue
    '#8844FF', // Purple
    '#FF44DD'  // Pink
];

function dodgeLoop() {
    if (!game || !game.running) return;

    const canvas = document.getElementById('dodge-canvas');
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Apply friction
    game.player.vx *= 0.95;
    game.player.vy *= 0.95;
    
    // Add thrust based on key presses
    const thrust = 0.6;
    if(keys['ArrowUp']) game.player.vy -= thrust;
    if(keys['ArrowDown']) game.player.vy += thrust;
    if(keys['ArrowLeft']) game.player.vx -= thrust;
    if(keys['ArrowRight']) game.player.vx += thrust;
    
    // Update position using velocity ONLY
    game.player.x += game.player.vx;
    game.player.y += game.player.vy;

    // Clamp player inside canvas
    game.player.x = Math.max(game.player.r, Math.min(canvas.width - game.player.r, game.player.x));
    game.player.y = Math.max(game.player.r, Math.min(canvas.height - game.player.r, game.player.y));

    // Draw player
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(game.player.x, game.player.y, game.player.r, 0, Math.PI * 2);
    ctx.fill();

    // Obstacle spawn - FIXED: Add random color to each obstacle
    game.timer++;
    if (game.timer > 30) {
        const side = Math.floor(Math.random() * 4);
        const speedMultiplier = 1 + Math.floor(game.score / 100) * 0.15;
        const colorIndex = Math.floor(Math.random() * OBSTACLE_COLORS.length);
        
        let obs = { 
            w: 22 + Math.random() * 42, 
            h: 22 + Math.random() * 42, 
            dx: 0, 
            dy: 0,
            color: OBSTACLE_COLORS[colorIndex] // Add random color
        };

        if (side === 0) { obs.x = -obs.w; obs.y = Math.random() * canvas.height; obs.dx = game.baseObstacleSpeed * speedMultiplier; }
        else if (side === 1) { obs.x = canvas.width; obs.y = Math.random() * canvas.height; obs.dx = -game.baseObstacleSpeed * speedMultiplier; }
        else if (side === 2) { obs.x = Math.random() * canvas.width; obs.y = -obs.h; obs.dy = game.baseObstacleSpeed * speedMultiplier; }
        else { obs.x = Math.random() * canvas.width; obs.y = canvas.height; obs.dy = -game.baseObstacleSpeed * speedMultiplier; }

        game.obstacles.push(obs);
        game.timer = 0;
    }

    // Draw obstacles & check collisions - FIXED: Use individual obstacle colors
    for (let i = game.obstacles.length - 1; i >= 0; i--) {
        const obs = game.obstacles[i];
        obs.x += obs.dx;
        obs.y += obs.dy;

        // Use the obstacle's individual color instead of fixed red
        ctx.fillStyle = obs.color;
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

        // Remove off-screen
        if (obs.x < -100 || obs.x > canvas.width + 100 || obs.y < -100 || obs.y > canvas.height + 100) {
            game.obstacles.splice(i, 1);
            game.score += 10;
            document.getElementById('dodge-score').textContent = game.score;
            continue;
        }

        // Collision detection
        const distX = game.player.x - (obs.x + obs.w / 2);
        const distY = game.player.y - (obs.y + obs.h / 2);
        const distance = Math.sqrt(distX * distX + distY * distY);
        if (distance < game.player.r + Math.min(obs.w, obs.h) / 2) {
            const isNewRecord = saveHighScore('dodge', game.score);
            const title = isNewRecord ? '🎉 New High Score!' : 'Hit!';
            showGameOver(title, `Score: ${game.score}`);
            return;
        }
    }

    animationFrameId = requestAnimationFrame(dodgeLoop);
}


// Touch swipe
let dodgeTouchStartX = null, dodgeTouchStartY = null, dodgeTouchStartTime = null;
const dodgeCanvas = document.getElementById('dodge-canvas');

dodgeCanvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    dodgeTouchStartX = t.clientX;
    dodgeTouchStartY = t.clientY;
    dodgeTouchStartTime = Date.now();
});

dodgeCanvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (!game || dodgeTouchStartX === null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - dodgeTouchStartX;
    const dy = t.clientY - dodgeTouchStartY;
    const dt = Date.now() - dodgeTouchStartTime;

    if (dt < 300) {
        game.player.vx += dx / 15;
        game.player.vy += dy / 15;
    }

    dodgeTouchStartX = dodgeTouchStartY = dodgeTouchStartTime = null;
});


// Touch buttons - FIXED: Added missing release function
const dodgeBtns = document.querySelectorAll('#dodge-touch-controls .tc-btn');
dodgeBtns.forEach(btn => {
    const key = btn.dataset.key;
    const press = e => { e.preventDefault(); keys[key] = true; };
    const release = e => { e.preventDefault(); keys[key] = false; }; // FIXED: Added missing release function

    btn.addEventListener('touchstart', press, { passive: false });
    btn.addEventListener('touchend', release);
    btn.addEventListener('touchcancel', release);
    btn.addEventListener('mousedown', press);
    btn.addEventListener('mouseup', release);
});

// Prevent scrolling on touch
document.querySelectorAll('canvas').forEach(c => {
    c.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
});

// Toggle info text
function toggleInfo() {
    const info = document.getElementById("infoText");
    if (info.style.display === "block") {
        info.style.display = "none";
    } else {
        info.style.display = "block";
    }
}

// Hide info if clicked away
document.addEventListener("click", (e) => {
    const info = document.getElementById("infoText");
    if (!e.target.classList.contains("info-btn") && info && !info.contains(e.target)) {
        info.style.display = "none";
    }
});
</script>
</body>
</html>
